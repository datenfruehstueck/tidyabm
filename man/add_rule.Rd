% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidyabm_class.R
\name{add_rule}
\alias{add_rule}
\alias{add_rule.tidyabm}
\title{Add a rule (i.e., an action that is performed under certain conditions)}
\usage{
add_rule(.tidyabm, .label, ..., .consequence)

\method{add_rule}{tidyabm}(.tidyabm, .label, ..., .consequence)
}
\arguments{
\item{.tidyabm}{a \code{tidyabm} object}

\item{.label}{string describing the rule}

\item{...}{<\code{\link[rlang:args_data_masking]{data-masking}}> expressions that
return a logical value and are defined in terms of all characteristics
and variables of \code{me} (which is the \code{tidyabm} object to which the rule
was applied to). If multiple expressions are included, they are combined
with the \code{&} operator.}

\item{.consequence}{function to be executed if all conditions apply. Use
a function with two arguments, \code{me} (which is the \code{tidyabm} object at that
specific point in time) and \code{abm} (which is the whole \code{tidyabm} object).
Note that for \code{tidyabm_env} objects these two arguments are the same but
for \code{tidyabm_agent} objects they are different in that the first (\code{me}) is
the current agent and the second (\code{abm}) is the whole environment model.
\strong{Importantly}, for any changes to apply the function has to return the
updated \code{me} (i.e., a \code{tidyabm_agent} object for agent rules and a
\code{tidyabm_env} object for environment rules). If the function misses to do
so, any changes will be ignored and a warning will be issued during
runtime. If you write your own functions or need to provide additional
arguments to functions, use the style of anonymized functions directly
in-line (through \verb{function(me, abm) ... return(me)} or
\verb{\\(me, abm) ... return(me)}).}
}
\value{
a \code{tidyabm} object
}
\description{
Rules are checked and executed once per tick. Rules for agents are run
before rules for environments. For each rule, the \code{...} conditions are
checked and, if they prove valid, the rule's \code{.consequence} is run.

Think of rules as the code to be run within your ABM. Rules could establish
connections or abort them, they could remove or add agents, they could
stop the whole simulation or make agents move.

For helping utilities (i.e., readily implemented helpers to be used in your
rules or as readymade consequences) and examples, see the full
documentation, particularly per environment type.
}
\examples{
create_agent() \%>\%
  set_characteristic(age = 15) \%>\%
  add_rule('minors move',
           age >= 18,
           .consequence = \(me, abm) {
             spot <- grid_get_free_neighboring_spots(me, abm) \%>\%
               dplyr::slice_sample(n = 1)
             grid_move(me, abm,
                       new_x = spot$.x,
                       new_y = spot$.y) \%>\%
               return()
           })

create_grid_environment(seed = 1269, size = 5) \%>\%
  add_variable(n_agents = \(me, abm) nrow(convert_agents_to_tibble(me))) \%>\%
  add_rule('no more agents',
           n_agents == 0,
           .consequence = stop_abm)

}
